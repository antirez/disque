'\" t
.\"     Title: JEMALLOC
.\"    Author: Jason Evans
.\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
.\"      Date: 09/24/2015
.\"    Manual: User Manual
.\"    Source: jemalloc 4.0.3-0-ge9192eacf8935e29fc62fddc2701f7942b1cc02c
.\"  Language: English
.\"
.TH "JEMALLOC" "3" "09/24/2015" "jemalloc 4.0.3-0-ge9192eacf893" "User Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
jemalloc \- general purpose memory allocation functions
.SH "LIBRARY"
.PP
This manual describes jemalloc 4\&.0\&.3\-0\-ge9192eacf8935e29fc62fddc2701f7942b1cc02c\&. More information can be found at the
\m[blue]\fBjemalloc website\fR\m[]\&\s-2\u[1]\d\s+2\&.
.SH "SYNOPSIS"
.sp
.ft B
.nf
#include <jemalloc/jemalloc\&.h>
.fi
.ft
.SS "Standard API"
.HP \w'void\ *malloc('u
.BI "void *malloc(size_t\ " "size" ");"
.HP \w'void\ *calloc('u
.BI "void *calloc(size_t\ " "number" ", size_t\ " "size" ");"
.HP \w'int\ posix_memalign('u
.BI "int posix_memalign(void\ **" "ptr" ", size_t\ " "alignment" ", size_t\ " "size" ");"
.HP \w'void\ *aligned_alloc('u
.BI "void *aligned_alloc(size_t\ " "alignment" ", size_t\ " "size" ");"
.HP \w'void\ *realloc('u
.BI "void *realloc(void\ *" "ptr" ", size_t\ " "size" ");"
.HP \w'void\ free('u
.BI "void free(void\ *" "ptr" ");"
.SS "Non\-standard API"
.HP \w'void\ *mallocx('u
.BI "void *mallocx(size_t\ " "size" ", int\ " "flags" ");"
.HP \w'void\ *rallocx('u
.BI "void *rallocx(void\ *" "ptr" ", size_t\ " "size" ", int\ " "flags" ");"
.HP \w'size_t\ xallocx('u
.BI "size_t xallocx(void\ *" "ptr" ", size_t\ " "size" ", size_t\ " "extra" ", int\ " "flags" ");"
.HP \w'size_t\ sallocx('u
.BI "size_t sallocx(void\ *" "ptr" ", int\ " "flags" ");"
.HP \w'void\ dallocx('u
.BI "void dallocx(void\ *" "ptr" ", int\ " "flags" ");"
.HP \w'void\ sdallocx('u
.BI "void sdallocx(void\ *" "ptr" ", size_t\ " "size" ", int\ " "flags" ");"
.HP \w'size_t\ nallocx('u
.BI "size_t nallocx(size_t\ " "size" ", int\ " "flags" ");"
.HP \w'int\ mallctl('u
.BI "int mallctl(const\ char\ *" "name" ", void\ *" "oldp" ", size_t\ *" "oldlenp" ", void\ *" "newp" ", size_t\ " "newlen" ");"
.HP \w'int\ mallctlnametomib('u
.BI "int mallctlnametomib(const\ char\ *" "name" ", size_t\ *" "mibp" ", size_t\ *" "miblenp" ");"
.HP \w'int\ mallctlbymib('u
.BI "int mallctlbymib(const\ size_t\ *" "mib" ", size_t\ " "miblen" ", void\ *" "oldp" ", size_t\ *" "oldlenp" ", void\ *" "newp" ", size_t\ " "newlen" ");"
.HP \w'void\ malloc_stats_print('u
.BI "void malloc_stats_print(void\ " "(*write_cb)" "\ (void\ *,\ const\ char\ *), void\ *" "cbopaque" ", const\ char\ *" "opts" ");"
.HP \w'size_t\ malloc_usable_size('u
.BI "size_t malloc_usable_size(const\ void\ *" "ptr" ");"
.HP \w'void\ (*malloc_message)('u
.BI "void (*malloc_message)(void\ *" "cbopaque" ", const\ char\ *" "s" ");"
.PP
const char *\fImalloc_conf\fR;
.SH "DESCRIPTION"
.SS "Standard API"
.PP
The
\fBmalloc\fR\fB\fR
function allocates
\fIsize\fR
bytes of uninitialized memory\&. The allocated space is suitably aligned (after possible pointer coercion) for storage of any type of object\&.
.PP
The
\fBcalloc\fR\fB\fR
function allocates space for
\fInumber\fR
objects, each
\fIsize\fR
bytes in length\&. The result is identical to calling
\fBmalloc\fR\fB\fR
with an argument of
\fInumber\fR
*
\fIsize\fR, with the exception that the allocated memory is explicitly initialized to zero bytes\&.
.PP
The
\fBposix_memalign\fR\fB\fR
function allocates
\fIsize\fR
bytes of memory such that the allocation\*(Aqs base address is a multiple of
\fIalignment\fR, and returns the allocation in the value pointed to by
\fIptr\fR\&. The requested
\fIalignment\fR
must be a power of 2 at least as large as
sizeof(\fBvoid *\fR)\&.
.PP
The
\fBaligned_alloc\fR\fB\fR
function allocates
\fIsize\fR
bytes of memory such that the allocation\*(Aqs base address is a multiple of
\fIalignment\fR\&. The requested
\fIalignment\fR
must be a power of 2\&. Behavior is undefined if
\fIsize\fR
is not an integral multiple of
\fIalignment\fR\&.
.PP
The
\fBrealloc\fR\fB\fR
function changes the size of the previously allocated memory referenced by
\fIptr\fR
to
\fIsize\fR
bytes\&. The contents of the memory are unchanged up to the lesser of the new and old sizes\&. If the new size is larger, the contents of the newly allocated portion of the memory are undefined\&. Upon success, the memory referenced by
\fIptr\fR
is freed and a pointer to the newly allocated memory is returned\&. Note that
\fBrealloc\fR\fB\fR
may move the memory allocation, resulting in a different return value than
\fIptr\fR\&. If
\fIptr\fR
is
\fBNULL\fR, the
\fBrealloc\fR\fB\fR
function behaves identically to
\fBmalloc\fR\fB\fR
for the specified size\&.
.PP
The
\fBfree\fR\fB\fR
function causes the allocated memory referenced by
\fIptr\fR
to be made available for future allocations\&. If
\fIptr\fR
is
\fBNULL\fR, no action occurs\&.
.SS "Non\-standard API"
.PP
The
\fBmallocx\fR\fB\fR,
\fBrallocx\fR\fB\fR,
\fBxallocx\fR\fB\fR,
\fBsallocx\fR\fB\fR,
\fBdallocx\fR\fB\fR,
\fBsdallocx\fR\fB\fR, and
\fBnallocx\fR\fB\fR
functions all have a
\fIflags\fR
argument that can be used to specify options\&. The functions only check the options that are contextually relevant\&. Use bitwise or (|) operations to specify one or more of the following:
.PP
\fBMALLOCX_LG_ALIGN(\fR\fB\fIla\fR\fR\fB) \fR
.RS 4
Align the memory allocation to start at an address that is a multiple of
(1 << \fIla\fR)\&. This macro does not validate that
\fIla\fR
is within the valid range\&.
.RE
.PP
\fBMALLOCX_ALIGN(\fR\fB\fIa\fR\fR\fB) \fR
.RS 4
Align the memory allocation to start at an address that is a multiple of
\fIa\fR, where
\fIa\fR
is a power of two\&. This macro does not validate that
\fIa\fR
is a power of 2\&.
.RE
.PP
\fBMALLOCX_ZERO\fR
.RS 4
Initialize newly allocated memory to contain zero bytes\&. In the growing reallocation case, the real size prior to reallocation defines the boundary between untouched bytes and those that are initialized to contain zero bytes\&. If this macro is absent, newly allocated memory is uninitialized\&.
.RE
.PP
\fBMALLOCX_TCACHE(\fR\fB\fItc\fR\fR\fB) \fR
.RS 4
Use the thread\-specific cache (tcache) specified by the identifier
\fItc\fR, which must have been acquired via the
"tcache\&.create"
mallctl\&. This macro does not validate that
\fItc\fR
specifies a valid identifier\&.
.RE
.PP
\fBMALLOCX_TCACHE_NONE\fR
.RS 4
Do not use a thread\-specific cache (tcache)\&. Unless
\fBMALLOCX_TCACHE(\fR\fB\fItc\fR\fR\fB)\fR
or
\fBMALLOCX_TCACHE_NONE\fR
is specified, an automatically managed tcache will be used under many circumstances\&. This macro cannot be used in the same
\fIflags\fR
argument as
\fBMALLOCX_TCACHE(\fR\fB\fItc\fR\fR\fB)\fR\&.
.RE
.PP
\fBMALLOCX_ARENA(\fR\fB\fIa\fR\fR\fB) \fR
.RS 4
Use the arena specified by the index
\fIa\fR\&. This macro has no effect for regions that were allocated via an arena other than the one specified\&. This macro does not validate that
\fIa\fR
specifies an arena index in the valid range\&.
.RE
.PP
The
\fBmallocx\fR\fB\fR
function allocates at least
\fIsize\fR
bytes of memory, and returns a pointer to the base address of the allocation\&. Behavior is undefined if
\fIsize\fR
is
\fB0\fR, or if request size overflows due to size class and/or alignment constraints\&.
.PP
The
\fBrallocx\fR\fB\fR
function resizes the allocation at
\fIptr\fR
to be at least
\fIsize\fR
bytes, and returns a pointer to the base address of the resulting allocation, which may or may not have moved from its original location\&. Behavior is undefined if
\fIsize\fR
is
\fB0\fR, or if request size overflows due to size class and/or alignment constraints\&.
.PP
The
\fBxallocx\fR\fB\fR
function resizes the allocation at
\fIptr\fR
in place to be at least
\fIsize\fR
bytes, and returns the real size of the allocation\&. If
\fIextra\fR
is non\-zero, an attempt is made to resize the allocation to be at least
(\fIsize\fR + \fIextra\fR)
bytes, though inability to allocate the extra byte(s) will not by itself result in failure to resize\&. Behavior is undefined if
\fIsize\fR
is
\fB0\fR, or if
(\fIsize\fR + \fIextra\fR > \fBSIZE_T_MAX\fR)\&.
.PP
The
\fBsallocx\fR\fB\fR
function returns the real size of the allocation at
\fIptr\fR\&.
.PP
The
\fBdallocx\fR\fB\fR
function causes the memory referenced by
\fIptr\fR
to be made available for future allocations\&.
.PP
The
\fBsdallocx\fR\fB\fR
function is an extension of
\fBdallocx\fR\fB\fR
with a
\fIsize\fR
parameter to allow the caller to pass in the allocation size as an optimization\&. The minimum valid input size is the original requested size of the allocation, and the maximum valid input size is the corresponding value returned by
\fBnallocx\fR\fB\fR
or
\fBsallocx\fR\fB\fR\&.
.PP
The
\fBnallocx\fR\fB\fR
function allocates no memory, but it performs the same size computation as the
\fBmallocx\fR\fB\fR
function, and returns the real size of the allocation that would result from the equivalent
\fBmallocx\fR\fB\fR
function call\&. Behavior is undefined if
\fIsize\fR
is
\fB0\fR, or if request size overflows due to size class and/or alignment constraints\&.
.PP
The
\fBmallctl\fR\fB\fR
function provides a general interface for introspecting the memory allocator, as well as setting modifiable parameters and triggering actions\&. The period\-separated
\fIname\fR
argument specifies a location in a tree\-structured namespace; see the
MALLCTL NAMESPACE
section for documentation on the tree contents\&. To read a value, pass a pointer via
\fIoldp\fR
to adequate space to contain the value, and a pointer to its length via
\fIoldlenp\fR; otherwise pass
\fBNULL\fR
and
\fBNULL\fR\&. Similarly, to write a value, pass a pointer to the value via
\fInewp\fR, and its length via
\fInewlen\fR; otherwise pass
\fBNULL\fR
and
\fB0\fR\&.
.PP
The
\fBmallctlnametomib\fR\fB\fR
function provides a way to avoid repeated name lookups for applications that repeatedly query the same portion of the namespace, by translating a name to a \(lqManagement Information Base\(rq (MIB) that can be passed repeatedly to
\fBmallctlbymib\fR\fB\fR\&. Upon successful return from
\fBmallctlnametomib\fR\fB\fR,
\fImibp\fR
contains an array of
\fI*miblenp\fR
integers, where
\fI*miblenp\fR
is the lesser of the number of components in
\fIname\fR
and the input value of
\fI*miblenp\fR\&. Thus it is possible to pass a
\fI*miblenp\fR
that is smaller than the number of period\-separated name components, which results in a partial MIB that can be used as the basis for constructing a complete MIB\&. For name components that are integers (e\&.g\&. the 2 in
"arenas\&.bin\&.2\&.size"), the corresponding MIB component will always be that integer\&. Therefore, it is legitimate to construct code like the following:
.sp
.if n \{\
.RS 4
.\}
.nf
unsigned nbins, i;
size_t mib[4];
size_t len, miblen;

len = sizeof(nbins);
mallctl("arenas\&.nbins", &nbins, &len, NULL, 0);

miblen = 4;
mallctlnametomib("arenas\&.bin\&.0\&.size", mib, &miblen);
for (i = 0; i < nbins; i++) {
	size_t bin_size;

	mib[2] = i;
	len = sizeof(bin_size);
	mallctlbymib(mib, miblen, &bin_size, &len, NULL, 0);
	/* Do something with bin_size\&.\&.\&. */
}
.fi
.if n \{\
.RE
.\}
.PP
The
\fBmalloc_stats_print\fR\fB\fR
function writes human\-readable summary statistics via the
\fIwrite_cb\fR
callback function pointer and
\fIcbopaque\fR
data passed to
\fIwrite_cb\fR, or
\fBmalloc_message\fR\fB\fR
if
\fIwrite_cb\fR
is
\fBNULL\fR\&. This function can be called repeatedly\&. General information that never changes during execution can be omitted by specifying "g" as a character within the
\fIopts\fR
string\&. Note that
\fBmalloc_message\fR\fB\fR
uses the
\fBmallctl*\fR\fB\fR
functions internally, so inconsistent statistics can be reported if multiple threads use these functions simultaneously\&. If
\fB\-\-enable\-stats\fR
is specified during configuration, \(lqm\(rq and \(lqa\(rq can be specified to omit merged arena and per arena statistics, respectively; \(lqb\(rq, \(lql\(rq, and \(lqh\(rq can be specified to omit per size class statistics for bins, large objects, and huge objects, respectively\&. Unrecognized characters are silently ignored\&. Note that thread caching may prevent some statistics from being completely up to date, since extra locking would be required to merge counters that track thread cache operations\&.
.PP
The
\fBmalloc_usable_size\fR\fB\fR
function returns the usable size of the allocation pointed to by
\fIptr\fR\&. The return value may be larger than the size that was requested during allocation\&. The
\fBmalloc_usable_size\fR\fB\fR
function is not a mechanism for in\-place
\fBrealloc\fR\fB\fR; rather it is provided solely as a tool for introspection purposes\&. Any discrepancy between the requested allocation size and the size reported by
\fBmalloc_usable_size\fR\fB\fR
should not be depended on, since such behavior is entirely implementation\-dependent\&.
.SH "TUNING"
.PP
Once, when the first call is made to one of the memory allocation routines, the allocator initializes its internals based in part on various options that can be specified at compile\- or run\-time\&.
.PP
The string pointed to by the global variable
\fImalloc_conf\fR, the \(lqname\(rq of the file referenced by the symbolic link named
/etc/malloc\&.conf, and the value of the environment variable
\fBMALLOC_CONF\fR, will be interpreted, in that order, from left to right as options\&. Note that
\fImalloc_conf\fR
may be read before
\fBmain\fR\fB\fR
is entered, so the declaration of
\fImalloc_conf\fR
should specify an initializer that contains the final value to be read by jemalloc\&.
\fImalloc_conf\fR
is a compile\-time setting, whereas
/etc/malloc\&.conf
and
\fBMALLOC_CONF\fR
can be safely set any time prior to program invocation\&.
.PP
An options string is a comma\-separated list of option:value pairs\&. There is one key corresponding to each
"opt\&.*"
mallctl (see the
MALLCTL NAMESPACE
section for options documentation)\&. For example,
abort:true,narenas:1
sets the
"opt\&.abort"
and
"opt\&.narenas"
options\&. Some options have boolean values (true/false), others have integer values (base 8, 10, or 16, depending on prefix), and yet others have raw string values\&.
.SH "IMPLEMENTATION NOTES"
.PP
Traditionally, allocators have used
\fBsbrk\fR(2)
to obtain memory, which is suboptimal for several reasons, including race conditions, increased fragmentation, and artificial limitations on maximum usable memory\&. If
\fBsbrk\fR(2)
is supported by the operating system, this allocator uses both
\fBmmap\fR(2)
and
\fBsbrk\fR(2), in that order of preference; otherwise only
\fBmmap\fR(2)
is used\&.
.PP
This allocator uses multiple arenas in order to reduce lock contention for threaded programs on multi\-processor systems\&. This works well with regard to threading scalability, but incurs some costs\&. There is a small fixed per\-arena overhead, and additionally, arenas manage memory completely independently of each other, which means a small fixed increase in overall memory fragmentation\&. These overheads are not generally an issue, given the number of arenas normally used\&. Note that using substantially more arenas than the default is not likely to improve performance, mainly due to reduced cache performance\&. However, it may make sense to reduce the number of arenas if an application does not make much use of the allocation functions\&.
.PP
In addition to multiple arenas, unless
\fB\-\-disable\-tcache\fR
is specified during configuration, this allocator supports thread\-specific caching for small and large objects, in order to make it possible to completely avoid synchronization for most allocation requests\&. Such caching allows very fast allocation in the common case, but it increases memory usage and fragmentation, since a bounded number of objects can remain allocated in each thread cache\&.
.PP
Memory is conceptually broken into equal\-sized chunks, where the chunk size is a power of two that is greater than the page size\&. Chunks are always aligned to multiples of the chunk size\&. This alignment makes it possible to find metadata for user objects very quickly\&.
.PP
User objects are broken into three categories according to size: small, large, and huge\&. Small and large objects are managed entirely by arenas; huge objects are additionally aggregated in a single data structure that is shared by all threads\&. Huge objects are typically used by applications infrequently enough that this single data structure is not a scalability issue\&.
.PP
Each chunk that is managed by an arena tracks its contents as runs of contiguous pages (unused, backing a set of small objects, or backing one large object)\&. The combination of chunk alignment and chunk page maps makes it possible to determine all metadata regarding small and large allocations in constant time\&.
.PP
Small objects are managed in groups by page runs\&. Each run maintains a bitmap to track which regions are in use\&. Allocation requests that are no more than half the quantum (8 or 16, depending on architecture) are rounded up to the nearest power of two that is at least
sizeof(\fBdouble\fR)\&. All other object size classes are multiples of the quantum, spaced such that there are four size classes for each doubling in size, which limits internal fragmentation to approximately 20% for all but the smallest size classes\&. Small size classes are smaller than four times the page size, large size classes are smaller than the chunk size (see the
"opt\&.lg_chunk"
option), and huge size classes extend from the chunk size up to one size class less than the full address space size\&.
.PP
Allocations are packed tightly together, which can be an issue for multi\-threaded applications\&. If you need to assure that allocations do not suffer from cacheline sharing, round your allocation requests up to the nearest multiple of the cacheline size, or specify cacheline alignment when allocating\&.
.PP
The
\fBrealloc\fR\fB\fR,
\fBrallocx\fR\fB\fR, and
\fBxallocx\fR\fB\fR
functions may resize allocations without moving them under limited circumstances\&. Unlike the
\fB*allocx\fR\fB\fR
API, the standard API does not officially round up the usable size of an allocation to the nearest size class, so technically it is necessary to call
\fBrealloc\fR\fB\fR
to grow e\&.g\&. a 9\-byte allocation to 16 bytes, or shrink a 16\-byte allocation to 9 bytes\&. Growth and shrinkage trivially succeeds in place as long as the pre\-size and post\-size both round up to the same size class\&. No other API guarantees are made regarding in\-place resizing, but the current implementation also tries to resize large and huge allocations in place, as long as the pre\-size and post\-size are both large or both huge\&. In such cases shrinkage always succeeds for large size classes, but for huge size classes the chunk allocator must support splitting (see
"arena\&.<i>\&.chunk_hooks")\&. Growth only succeeds if the trailing memory is currently available, and additionally for huge size classes the chunk allocator must support merging\&.
.PP
Assuming 2 MiB chunks, 4 KiB pages, and a 16\-byte quantum on a 64\-bit system, the size classes in each category are as shown in
Table 1\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&1.\ \&Size classes
.TS
allbox tab(:);
lB rB lB.
T{
Category
T}:T{
Spacing
T}:T{
Size
T}
.T&
l r l
^ r l
^ r l
^ r l
^ r l
^ r l
^ r l
^ r l
^ r l
l r l
^ r l
^ r l
^ r l
^ r l
^ r l
^ r l
^ r l
l r l
^ r l
^ r l
^ r l
^ r l
^ r l
^ r l.
T{
Small
T}:T{
lg
T}:T{
[8]
T}
:T{
16
T}:T{
[16, 32, 48, 64, 80, 96, 112, 128]
T}
:T{
32
T}:T{
[160, 192, 224, 256]
T}
:T{
64
T}:T{
[320, 384, 448, 512]
T}
:T{
128
T}:T{
[640, 768, 896, 1024]
T}
:T{
256
T}:T{
[1280, 1536, 1792, 2048]
T}
:T{
512
T}:T{
[2560, 3072, 3584, 4096]
T}
:T{
1 KiB
T}:T{
[5 KiB, 6 KiB, 7 KiB, 8 KiB]
T}
:T{
2 KiB
T}:T{
[10 KiB, 12 KiB, 14 KiB]
T}
T{
Large
T}:T{
2 KiB
T}:T{
[16 KiB]
T}
:T{
4 KiB
T}:T{
[20 KiB, 24 KiB, 28 KiB, 32 KiB]
T}
:T{
8 KiB
T}:T{
[40 KiB, 48 KiB, 54 KiB, 64 KiB]
T}
:T{
16 KiB
T}:T{
[80 KiB, 96 KiB, 112 KiB, 128 KiB]
T}
:T{
32 KiB
T}:T{
[160 KiB, 192 KiB, 224 KiB, 256 KiB]
T}
:T{
64 KiB
T}:T{
[320 KiB, 384 KiB, 448 KiB, 512 KiB]
T}
:T{
128 KiB
T}:T{
[640 KiB, 768 KiB, 896 KiB, 1 MiB]
T}
:T{
256 KiB
T}:T{
[1280 KiB, 1536 KiB, 1792 KiB]
T}
T{
Huge
T}:T{
256 KiB
T}:T{
[2 MiB]
T}
:T{
512 KiB
T}:T{
[2560 KiB, 3 MiB, 3584 KiB, 4 MiB]
T}
:T{
1 MiB
T}:T{
[5 MiB, 6 MiB, 7 MiB, 8 MiB]
T}
:T{
2 MiB
T}:T{
[10 MiB, 12 MiB, 14 MiB, 16 MiB]
T}
:T{
4 MiB
T}:T{
[20 MiB, 24 MiB, 28 MiB, 32 MiB]
T}
:T{
8 MiB
T}:T{
[40 MiB, 48 MiB, 56 MiB, 64 MiB]
T}
:T{
\&.\&.\&.
T}:T{
\&.\&.\&.
T}
.TE
.sp 1
.SH "MALLCTL NAMESPACE"
.PP
The following names are defined in the namespace accessible via the
\fBmallctl*\fR\fB\fR
functions\&. Value types are specified in parentheses, their readable/writable statuses are encoded as
rw,
r\-,
\-w, or
\-\-, and required build configuration flags follow, if any\&. A name element encoded as
<i>
or
<j>
indicates an integer component, where the integer varies from 0 to some upper value that must be determined via introspection\&. In the case of
"stats\&.arenas\&.<i>\&.*",
<i>
equal to
"arenas\&.narenas"
can be used to access the summation of statistics from all arenas\&. Take special note of the
"epoch"
mallctl, which controls refreshing of cached dynamic statistics\&.
.PP
"version" (\fBconst char *\fR) r\-
.RS 4
Return the jemalloc version string\&.
.RE
.PP
"epoch" (\fBuint64_t\fR) rw
.RS 4
If a value is passed in, refresh the data from which the
\fBmallctl*\fR\fB\fR
functions report values, and increment the epoch\&. Return the current epoch\&. This is useful for detecting whether another thread caused a refresh\&.
.RE
.PP
"config\&.cache_oblivious" (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-cache\-oblivious\fR
was specified during build configuration\&.
.RE
.PP
"config\&.debug" (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-debug\fR
was specified during build configuration\&.
.RE
.PP
"config\&.fill" (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-fill\fR
was specified during build configuration\&.
.RE
.PP
"config\&.lazy_lock" (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-lazy\-lock\fR
was specified during build configuration\&.
.RE
.PP
"config\&.munmap" (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-munmap\fR
was specified during build configuration\&.
.RE
.PP
"config\&.prof" (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-prof\fR
was specified during build configuration\&.
.RE
.PP
"config\&.prof_libgcc" (\fBbool\fR) r\-
.RS 4
\fB\-\-disable\-prof\-libgcc\fR
was not specified during build configuration\&.
.RE
.PP
"config\&.prof_libunwind" (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-prof\-libunwind\fR
was specified during build configuration\&.
.RE
.PP
"config\&.stats" (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-stats\fR
was specified during build configuration\&.
.RE
.PP
"config\&.tcache" (\fBbool\fR) r\-
.RS 4
\fB\-\-disable\-tcache\fR
was not specified during build configuration\&.
.RE
.PP
"config\&.tls" (\fBbool\fR) r\-
.RS 4
\fB\-\-disable\-tls\fR
was not specified during build configuration\&.
.RE
.PP
"config\&.utrace" (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-utrace\fR
was specified during build configuration\&.
.RE
.PP
"config\&.valgrind" (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-valgrind\fR
was specified during build configuration\&.
.RE
.PP
"config\&.xmalloc" (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-xmalloc\fR
was specified during build configuration\&.
.RE
.PP
"opt\&.abort" (\fBbool\fR) r\-
.RS 4
Abort\-on\-warning enabled/disabled\&. If true, most warnings are fatal\&. The process will call
\fBabort\fR(3)
in these cases\&. This option is disabled by default unless
\fB\-\-enable\-debug\fR
is specified during configuration, in which case it is enabled by default\&.
.RE
.PP
"opt\&.dss" (\fBconst char *\fR) r\-
.RS 4
dss (\fBsbrk\fR(2)) allocation precedence as related to
\fBmmap\fR(2)
allocation\&. The following settings are supported if
\fBsbrk\fR(2)
is supported by the operating system: \(lqdisabled\(rq, \(lqprimary\(rq, and \(lqsecondary\(rq; otherwise only \(lqdisabled\(rq is supported\&. The default is \(lqsecondary\(rq if
\fBsbrk\fR(2)
is supported by the operating system; \(lqdisabled\(rq otherwise\&.
.RE
.PP
"opt\&.lg_chunk" (\fBsize_t\fR) r\-
.RS 4
Virtual memory chunk size (log base 2)\&. If a chunk size outside the supported size range is specified, the size is silently clipped to the minimum/maximum supported size\&. The default chunk size is 2 MiB (2^21)\&.
.RE
.PP
"opt\&.narenas" (\fBsize_t\fR) r\-
.RS 4
Maximum number of arenas to use for automatic multiplexing of threads and arenas\&. The default is four times the number of CPUs, or one if there is a single CPU\&.
.RE
.PP
"opt\&.lg_dirty_mult" (\fBssize_t\fR) r\-
.RS 4
Per\-arena minimum ratio (log base 2) of active to dirty pages\&. Some dirty unused pages may be allowed to accumulate, within the limit set by the ratio (or one chunk worth of dirty pages, whichever is greater), before informing the kernel about some of those pages via
\fBmadvise\fR(2)
or a similar system call\&. This provides the kernel with sufficient information to recycle dirty pages if physical memory becomes scarce and the pages remain unused\&. The default minimum ratio is 8:1 (2^3:1); an option value of \-1 will disable dirty page purging\&. See
"arenas\&.lg_dirty_mult"
and
"arena\&.<i>\&.lg_dirty_mult"
for related dynamic control options\&.
.RE
.PP
"opt\&.stats_print" (\fBbool\fR) r\-
.RS 4
Enable/disable statistics printing at exit\&. If enabled, the
\fBmalloc_stats_print\fR\fB\fR
function is called at program exit via an
\fBatexit\fR(3)
function\&. If
\fB\-\-enable\-stats\fR
is specified during configuration, this has the potential to cause deadlock for a multi\-threaded process that exits while one or more threads are executing in the memory allocation functions\&. Furthermore,
\fBatexit\fR\fB\fR
may allocate memory during application initialization and then deadlock internally when jemalloc in turn calls
\fBatexit\fR\fB\fR, so this option is not univerally usable (though the application can register its own
\fBatexit\fR\fB\fR
function with equivalent functionality)\&. Therefore, this option should only be used with care; it is primarily intended as a performance tuning aid during application development\&. This option is disabled by default\&.
.RE
.PP
"opt\&.junk" (\fBconst char *\fR) r\- [\fB\-\-enable\-fill\fR]
.RS 4
Junk filling\&. If set to "alloc", each byte of uninitialized allocated memory will be initialized to
0xa5\&. If set to "free", all deallocated memory will be initialized to
0x5a\&. If set to "true", both allocated and deallocated memory will be initialized, and if set to "false", junk filling be disabled entirely\&. This is intended for debugging and will impact performance negatively\&. This option is "false" by default unless
\fB\-\-enable\-debug\fR
is specified during configuration, in which case it is "true" by default unless running inside
\m[blue]\fBValgrind\fR\m[]\&\s-2\u[2]\d\s+2\&.
.RE
.PP
"opt\&.quarantine" (\fBsize_t\fR) r\- [\fB\-\-enable\-fill\fR]
.RS 4
Per thread quarantine size in bytes\&. If non\-zero, each thread maintains a FIFO object quarantine that stores up to the specified number of bytes of memory\&. The quarantined memory is not freed until it is released from quarantine, though it is immediately junk\-filled if the
"opt\&.junk"
option is enabled\&. This feature is of particular use in combination with
\m[blue]\fBValgrind\fR\m[]\&\s-2\u[2]\d\s+2, which can detect attempts to access quarantined objects\&. This is intended for debugging and will impact performance negatively\&. The default quarantine size is 0 unless running inside Valgrind, in which case the default is 16 MiB\&.
.RE
.PP
"opt\&.redzone" (\fBbool\fR) r\- [\fB\-\-enable\-fill\fR]
.RS 4
Redzones enabled/disabled\&. If enabled, small allocations have redzones before and after them\&. Furthermore, if the
"opt\&.junk"
option is enabled, the redzones are checked for corruption during deallocation\&. However, the primary intended purpose of this feature is to be used in combination with
\m[blue]\fBValgrind\fR\m[]\&\s-2\u[2]\d\s+2, which needs redzones in order to do effective buffer overflow/underflow detection\&. This option is intended for debugging and will impact performance negatively\&. This option is disabled by default unless running inside Valgrind\&.
.RE
.PP
"opt\&.zero" (\fBbool\fR) r\- [\fB\-\-enable\-fill\fR]
.RS 4
Zero filling enabled/disabled\&. If enabled, each byte of uninitialized allocated memory will be initialized to 0\&. Note that this initialization only happens once for each byte, so
\fBrealloc\fR\fB\fR
and
\fBrallocx\fR\fB\fR
calls do not zero memory that was previously allocated\&. This is intended for debugging and will impact performance negatively\&. This option is disabled by default\&.
.RE
.PP
"opt\&.utrace" (\fBbool\fR) r\- [\fB\-\-enable\-utrace\fR]
.RS 4
Allocation tracing based on
\fButrace\fR(2)
enabled/disabled\&. This option is disabled by default\&.
.RE
.PP
"opt\&.xmalloc" (\fBbool\fR) r\- [\fB\-\-enable\-xmalloc\fR]
.RS 4
Abort\-on\-out\-of\-memory enabled/disabled\&. If enabled, rather than returning failure for any allocation function, display a diagnostic message on
\fBSTDERR_FILENO\fR
and cause the program to drop core (using
\fBabort\fR(3))\&. If an application is designed to depend on this behavior, set the option at compile time by including the following in the source code:
.sp
.if n \{\
.RS 4
.\}
.nf
malloc_conf = "xmalloc:true";
.fi
.if n \{\
.RE
.\}
.sp
This option is disabled by default\&.
.RE
.PP
"opt\&.tcache" (\fBbool\fR) r\- [\fB\-\-enable\-tcache\fR]
.RS 4
Thread\-specific caching (tcache) enabled/disabled\&. When there are multiple threads, each thread uses a tcache for objects up to a certain size\&. Thread\-specific caching allows many allocations to be satisfied without performing any thread synchronization, at the cost of increased memory use\&. See the
"opt\&.lg_tcache_max"
option for related tuning information\&. This option is enabled by default unless running inside
\m[blue]\fBValgrind\fR\m[]\&\s-2\u[2]\d\s+2, in which case it is forcefully disabled\&.
.RE
.PP
"opt\&.lg_tcache_max" (\fBsize_t\fR) r\- [\fB\-\-enable\-tcache\fR]
.RS 4
Maximum size class (log base 2) to cache in the thread\-specific cache (tcache)\&. At a minimum, all small size classes are cached, and at a maximum all large size classes are cached\&. The default maximum is 32 KiB (2^15)\&.
.RE
.PP
"opt\&.prof" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Memory profiling enabled/disabled\&. If enabled, profile memory allocation activity\&. See the
"opt\&.prof_active"
option for on\-the\-fly activation/deactivation\&. See the
"opt\&.lg_prof_sample"
option for probabilistic sampling control\&. See the
"opt\&.prof_accum"
option for control of cumulative sample reporting\&. See the
"opt\&.lg_prof_interval"
option for information on interval\-triggered profile dumping, the
"opt\&.prof_gdump"
option for information on high\-water\-triggered profile dumping, and the
"opt\&.prof_final"
option for final profile dumping\&. Profile output is compatible with the
\fBjeprof\fR
command, which is based on the
\fBpprof\fR
that is developed as part of the
\m[blue]\fBgperftools package\fR\m[]\&\s-2\u[3]\d\s+2\&.
.RE
.PP
"opt\&.prof_prefix" (\fBconst char *\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Filename prefix for profile dumps\&. If the prefix is set to the empty string, no automatic dumps will occur; this is primarily useful for disabling the automatic final heap dump (which also disables leak reporting, if enabled)\&. The default prefix is
jeprof\&.
.RE
.PP
"opt\&.prof_active" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Profiling activated/deactivated\&. This is a secondary control mechanism that makes it possible to start the application with profiling enabled (see the
"opt\&.prof"
option) but inactive, then toggle profiling at any time during program execution with the
"prof\&.active"
mallctl\&. This option is enabled by default\&.
.RE
.PP
"opt\&.prof_thread_active_init" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Initial setting for
"thread\&.prof\&.active"
in newly created threads\&. The initial setting for newly created threads can also be changed during execution via the
"prof\&.thread_active_init"
mallctl\&. This option is enabled by default\&.
.RE
.PP
"opt\&.lg_prof_sample" (\fBsize_t\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Average interval (log base 2) between allocation samples, as measured in bytes of allocation activity\&. Increasing the sampling interval decreases profile fidelity, but also decreases the computational overhead\&. The default sample interval is 512 KiB (2^19 B)\&.
.RE
.PP
"opt\&.prof_accum" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Reporting of cumulative object/byte counts in profile dumps enabled/disabled\&. If this option is enabled, every unique backtrace must be stored for the duration of execution\&. Depending on the application, this can impose a large memory overhead, and the cumulative counts are not always of interest\&. This option is disabled by default\&.
.RE
.PP
"opt\&.lg_prof_interval" (\fBssize_t\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Average interval (log base 2) between memory profile dumps, as measured in bytes of allocation activity\&. The actual interval between dumps may be sporadic because decentralized allocation counters are used to avoid synchronization bottlenecks\&. Profiles are dumped to files named according to the pattern
<prefix>\&.<pid>\&.<seq>\&.i<iseq>\&.heap, where
<prefix>
is controlled by the
"opt\&.prof_prefix"
option\&. By default, interval\-triggered profile dumping is disabled (encoded as \-1)\&.
.RE
.PP
"opt\&.prof_gdump" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Set the initial state of
"prof\&.gdump", which when enabled triggers a memory profile dump every time the total virtual memory exceeds the previous maximum\&. This option is disabled by default\&.
.RE
.PP
"opt\&.prof_final" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Use an
\fBatexit\fR(3)
function to dump final memory usage to a file named according to the pattern
<prefix>\&.<pid>\&.<seq>\&.f\&.heap, where
<prefix>
is controlled by the
"opt\&.prof_prefix"
option\&. Note that
\fBatexit\fR\fB\fR
may allocate memory during application initialization and then deadlock internally when jemalloc in turn calls
\fBatexit\fR\fB\fR, so this option is not univerally usable (though the application can register its own
\fBatexit\fR\fB\fR
function with equivalent functionality)\&. This option is disabled by default\&.
.RE
.PP
"opt\&.prof_leak" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Leak reporting enabled/disabled\&. If enabled, use an
\fBatexit\fR(3)
function to report memory leaks detected by allocation sampling\&. See the
"opt\&.prof"
option for information on analyzing heap profile output\&. This option is disabled by default\&.
.RE
.PP
"thread\&.arena" (\fBunsigned\fR) rw
.RS 4
Get or set the arena associated with the calling thread\&. If the specified arena was not initialized beforehand (see the
"arenas\&.initialized"
mallctl), it will be automatically initialized as a side effect of calling this interface\&.
.RE
.PP
"thread\&.allocated" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Get the total number of bytes ever allocated by the calling thread\&. This counter has the potential to wrap around; it is up to the application to appropriately interpret the counter in such cases\&.
.RE
.PP
"thread\&.allocatedp" (\fBuint64_t *\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Get a pointer to the the value that is returned by the
"thread\&.allocated"
mallctl\&. This is useful for avoiding the overhead of repeated
\fBmallctl*\fR\fB\fR
calls\&.
.RE
.PP
"thread\&.deallocated" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Get the total number of bytes ever deallocated by the calling thread\&. This counter has the potential to wrap around; it is up to the application to appropriately interpret the counter in such cases\&.
.RE
.PP
"thread\&.deallocatedp" (\fBuint64_t *\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Get a pointer to the the value that is returned by the
"thread\&.deallocated"
mallctl\&. This is useful for avoiding the overhead of repeated
\fBmallctl*\fR\fB\fR
calls\&.
.RE
.PP
"thread\&.tcache\&.enabled" (\fBbool\fR) rw [\fB\-\-enable\-tcache\fR]
.RS 4
Enable/disable calling thread\*(Aqs tcache\&. The tcache is implicitly flushed as a side effect of becoming disabled (see
"thread\&.tcache\&.flush")\&.
.RE
.PP
"thread\&.tcache\&.flush" (\fBvoid\fR) \-\- [\fB\-\-enable\-tcache\fR]
.RS 4
Flush calling thread\*(Aqs thread\-specific cache (tcache)\&. This interface releases all cached objects and internal data structures associated with the calling thread\*(Aqs tcache\&. Ordinarily, this interface need not be called, since automatic periodic incremental garbage collection occurs, and the thread cache is automatically discarded when a thread exits\&. However, garbage collection is triggered by allocation activity, so it is possible for a thread that stops allocating/deallocating to retain its cache indefinitely, in which case the developer may find manual flushing useful\&.
.RE
.PP
"thread\&.prof\&.name" (\fBconst char *\fR) r\- or \-w [\fB\-\-enable\-prof\fR]
.RS 4
Get/set the descriptive name associated with the calling thread in memory profile dumps\&. An internal copy of the name string is created, so the input string need not be maintained after this interface completes execution\&. The output string of this interface should be copied for non\-ephemeral uses, because multiple implementation details can cause asynchronous string deallocation\&. Furthermore, each invocation of this interface can only read or write; simultaneous read/write is not supported due to string lifetime limitations\&. The name string must nil\-terminated and comprised only of characters in the sets recognized by
\fBisgraph\fR(3)
and
\fBisblank\fR(3)\&.
.RE
.PP
"thread\&.prof\&.active" (\fBbool\fR) rw [\fB\-\-enable\-prof\fR]
.RS 4
Control whether sampling is currently active for the calling thread\&. This is an activation mechanism in addition to
"prof\&.active"; both must be active for the calling thread to sample\&. This flag is enabled by default\&.
.RE
.PP
"tcache\&.create" (\fBunsigned\fR) r\- [\fB\-\-enable\-tcache\fR]
.RS 4
Create an explicit thread\-specific cache (tcache) and return an identifier that can be passed to the
\fBMALLOCX_TCACHE(\fR\fB\fItc\fR\fR\fB)\fR
macro to explicitly use the specified cache rather than the automatically managed one that is used by default\&. Each explicit cache can be used by only one thread at a time; the application must assure that this constraint holds\&.
.RE
.PP
"tcache\&.flush" (\fBunsigned\fR) \-w [\fB\-\-enable\-tcache\fR]
.RS 4
Flush the specified thread\-specific cache (tcache)\&. The same considerations apply to this interface as to
"thread\&.tcache\&.flush", except that the tcache will never be automatically be discarded\&.
.RE
.PP
"tcache\&.destroy" (\fBunsigned\fR) \-w [\fB\-\-enable\-tcache\fR]
.RS 4
Flush the specified thread\-specific cache (tcache) and make the identifier available for use during a future tcache creation\&.
.RE
.PP
"arena\&.<i>\&.purge" (\fBvoid\fR) \-\-
.RS 4
Purge unused dirty pages for arena <i>, or for all arenas if <i> equals
"arenas\&.narenas"\&.
.RE
.PP
"arena\&.<i>\&.dss" (\fBconst char *\fR) rw
.RS 4
Set the precedence of dss allocation as related to mmap allocation for arena <i>, or for all arenas if <i> equals
"arenas\&.narenas"\&. See
"opt\&.dss"
for supported settings\&.
.RE
.PP
"arena\&.<i>\&.lg_dirty_mult" (\fBssize_t\fR) rw
.RS 4
Current per\-arena minimum ratio (log base 2) of active to dirty pages for arena <i>\&. Each time this interface is set and the ratio is increased, pages are synchronously purged as necessary to impose the new ratio\&. See
"opt\&.lg_dirty_mult"
for additional information\&.
.RE
.PP
"arena\&.<i>\&.chunk_hooks" (\fBchunk_hooks_t\fR) rw
.RS 4
Get or set the chunk management hook functions for arena <i>\&. The functions must be capable of operating on all extant chunks associated with arena <i>, usually by passing unknown chunks to the replaced functions\&. In practice, it is feasible to control allocation for arenas created via
"arenas\&.extend"
such that all chunks originate from an application\-supplied chunk allocator (by setting custom chunk hook functions just after arena creation), but the automatically created arenas may have already created chunks prior to the application having an opportunity to take over chunk allocation\&.
.sp
.if n \{\
.RS 4
.\}
.nf
typedef struct {
	chunk_alloc_t		*alloc;
	chunk_dalloc_t		*dalloc;
	chunk_commit_t		*commit;
	chunk_decommit_t	*decommit;
	chunk_purge_t		*purge;
	chunk_split_t		*split;
	chunk_merge_t		*merge;
} chunk_hooks_t;
.fi
.if n \{\
.RE
.\}
.sp
The
\fBchunk_hooks_t\fR
structure comprises function pointers which are described individually below\&. jemalloc uses these functions to manage chunk lifetime, which starts off with allocation of mapped committed memory, in the simplest case followed by deallocation\&. However, there are performance and platform reasons to retain chunks for later reuse\&. Cleanup attempts cascade from deallocation to decommit to purging, which gives the chunk management functions opportunities to reject the most permanent cleanup operations in favor of less permanent (and often less costly) operations\&. The chunk splitting and merging operations can also be opted out of, but this is mainly intended to support platforms on which virtual memory mappings provided by the operating system kernel do not automatically coalesce and split, e\&.g\&. Windows\&.
.HP \w'typedef\ void\ *(chunk_alloc_t)('u
.BI "typedef void *(chunk_alloc_t)(void\ *" "chunk" ", size_t\ " "size" ", size_t\ " "alignment" ", bool\ *" "zero" ", bool\ *" "commit" ", unsigned\ " "arena_ind" ");"
.sp
.if n \{\
.RS 4
.\}
.nf
.fi
.if n \{\
.RE
.\}
.sp
A chunk allocation function conforms to the
\fBchunk_alloc_t\fR
type and upon success returns a pointer to
\fIsize\fR
bytes of mapped memory on behalf of arena
\fIarena_ind\fR
such that the chunk\*(Aqs base address is a multiple of
\fIalignment\fR, as well as setting
\fI*zero\fR
to indicate whether the chunk is zeroed and
\fI*commit\fR
to indicate whether the chunk is committed\&. Upon error the function returns
\fBNULL\fR
and leaves
\fI*zero\fR
and
\fI*commit\fR
unmodified\&. The
\fIsize\fR
parameter is always a multiple of the chunk size\&. The
\fIalignment\fR
parameter is always a power of two at least as large as the chunk size\&. Zeroing is mandatory if
\fI*zero\fR
is true upon function entry\&. Committing is mandatory if
\fI*commit\fR
is true upon function entry\&. If
\fIchunk\fR
is not
\fBNULL\fR, the returned pointer must be
\fIchunk\fR
on success or
\fBNULL\fR
on error\&. Committed memory may be committed in absolute terms as on a system that does not overcommit, or in implicit terms as on a system that overcommits and satisfies physical memory needs on demand via soft page faults\&. Note that replacing the default chunk allocation function makes the arena\*(Aqs
"arena\&.<i>\&.dss"
setting irrelevant\&.
.HP \w'typedef\ bool\ (chunk_dalloc_t)('u
.BI "typedef bool (chunk_dalloc_t)(void\ *" "chunk" ", size_t\ " "size" ", bool\ " "committed" ", unsigned\ " "arena_ind" ");"
.sp
.if n \{\
.RS 4
.\}
.nf
.fi
.if n \{\
.RE
.\}
.sp
A chunk deallocation function conforms to the
\fBchunk_dalloc_t\fR
type and deallocates a
\fIchunk\fR
of given
\fIsize\fR
with
\fIcommitted\fR/decommited memory as indicated, on behalf of arena
\fIarena_ind\fR, returning false upon success\&. If the function returns true, this indicates opt\-out from deallocation; the virtual memory mapping associated with the chunk remains mapped, in the same commit state, and available for future use, in which case it will be automatically retained for later reuse\&.
.HP \w'typedef\ bool\ (chunk_commit_t)('u
.BI "typedef bool (chunk_commit_t)(void\ *" "chunk" ", size_t\ " "size" ", size_t\ " "offset" ", size_t\ " "length" ", unsigned\ " "arena_ind" ");"
.sp
.if n \{\
.RS 4
.\}
.nf
.fi
.if n \{\
.RE
.\}
.sp
A chunk commit function conforms to the
\fBchunk_commit_t\fR
type and commits zeroed physical memory to back pages within a
\fIchunk\fR
of given
\fIsize\fR
at
\fIoffset\fR
bytes, extending for
\fIlength\fR
on behalf of arena
\fIarena_ind\fR, returning false upon success\&. Committed memory may be committed in absolute terms as on a system that does not overcommit, or in implicit terms as on a system that overcommits and satisfies physical memory needs on demand via soft page faults\&. If the function returns true, this indicates insufficient physical memory to satisfy the request\&.
.HP \w'typedef\ bool\ (chunk_decommit_t)('u
.BI "typedef bool (chunk_decommit_t)(void\ *" "chunk" ", size_t\ " "size" ", size_t\ " "offset" ", size_t\ " "length" ", unsigned\ " "arena_ind" ");"
.sp
.if n \{\
.RS 4
.\}
.nf
.fi
.if n \{\
.RE
.\}
.sp
A chunk decommit function conforms to the
\fBchunk_decommit_t\fR
type and decommits any physical memory that is backing pages within a
\fIchunk\fR
of given
\fIsize\fR
at
\fIoffset\fR
bytes, extending for
\fIlength\fR
on behalf of arena
\fIarena_ind\fR, returning false upon success, in which case the pages will be committed via the chunk commit function before being reused\&. If the function returns true, this indicates opt\-out from decommit; the memory remains committed and available for future use, in which case it will be automatically retained for later reuse\&.
.HP \w'typedef\ bool\ (chunk_purge_t)('u
.BI "typedef bool (chunk_purge_t)(void\ *" "chunk" ", size_t" "size" ", size_t\ " "offset" ", size_t\ " "length" ", unsigned\ " "arena_ind" ");"
.sp
.if n \{\
.RS 4
.\}
.nf
.fi
.if n \{\
.RE
.\}
.sp
A chunk purge function conforms to the
\fBchunk_purge_t\fR
type and optionally discards physical pages within the virtual memory mapping associated with
\fIchunk\fR
of given
\fIsize\fR
at
\fIoffset\fR
bytes, extending for
\fIlength\fR
on behalf of arena
\fIarena_ind\fR, returning false if pages within the purged virtual memory range will be zero\-filled the next time they are accessed\&.
.HP \w'typedef\ bool\ (chunk_split_t)('u
.BI "typedef bool (chunk_split_t)(void\ *" "chunk" ", size_t\ " "size" ", size_t\ " "size_a" ", size_t\ " "size_b" ", bool\ " "committed" ", unsigned\ " "arena_ind" ");"
.sp
.if n \{\
.RS 4
.\}
.nf
.fi
.if n \{\
.RE
.\}
.sp
A chunk split function conforms to the
\fBchunk_split_t\fR
type and optionally splits
\fIchunk\fR
of given
\fIsize\fR
into two adjacent chunks, the first of
\fIsize_a\fR
bytes, and the second of
\fIsize_b\fR
bytes, operating on
\fIcommitted\fR/decommitted memory as indicated, on behalf of arena
\fIarena_ind\fR, returning false upon success\&. If the function returns true, this indicates that the chunk remains unsplit and therefore should continue to be operated on as a whole\&.
.HP \w'typedef\ bool\ (chunk_merge_t)('u
.BI "typedef bool (chunk_merge_t)(void\ *" "chunk_a" ", size_t\ " "size_a" ", void\ *" "chunk_b" ", size_t\ " "size_b" ", bool\ " "committed" ", unsigned\ " "arena_ind" ");"
.sp
.if n \{\
.RS 4
.\}
.nf
.fi
.if n \{\
.RE
.\}
.sp
A chunk merge function conforms to the
\fBchunk_merge_t\fR
type and optionally merges adjacent chunks,
\fIchunk_a\fR
of given
\fIsize_a\fR
and
\fIchunk_b\fR
of given
\fIsize_b\fR
into one contiguous chunk, operating on
\fIcommitted\fR/decommitted memory as indicated, on behalf of arena
\fIarena_ind\fR, returning false upon success\&. If the function returns true, this indicates that the chunks remain distinct mappings and therefore should continue to be operated on independently\&.
.RE
.PP
"arenas\&.narenas" (\fBunsigned\fR) r\-
.RS 4
Current limit on number of arenas\&.
.RE
.PP
"arenas\&.initialized" (\fBbool *\fR) r\-
.RS 4
An array of
"arenas\&.narenas"
booleans\&. Each boolean indicates whether the corresponding arena is initialized\&.
.RE
.PP
"arenas\&.lg_dirty_mult" (\fBssize_t\fR) rw
.RS 4
Current default per\-arena minimum ratio (log base 2) of active to dirty pages, used to initialize
"arena\&.<i>\&.lg_dirty_mult"
during arena creation\&. See
"opt\&.lg_dirty_mult"
for additional information\&.
.RE
.PP
"arenas\&.quantum" (\fBsize_t\fR) r\-
.RS 4
Quantum size\&.
.RE
.PP
"arenas\&.page" (\fBsize_t\fR) r\-
.RS 4
Page size\&.
.RE
.PP
"arenas\&.tcache_max" (\fBsize_t\fR) r\- [\fB\-\-enable\-tcache\fR]
.RS 4
Maximum thread\-cached size class\&.
.RE
.PP
"arenas\&.nbins" (\fBunsigned\fR) r\-
.RS 4
Number of bin size classes\&.
.RE
.PP
"arenas\&.nhbins" (\fBunsigned\fR) r\- [\fB\-\-enable\-tcache\fR]
.RS 4
Total number of thread cache bin size classes\&.
.RE
.PP
"arenas\&.bin\&.<i>\&.size" (\fBsize_t\fR) r\-
.RS 4
Maximum size supported by size class\&.
.RE
.PP
"arenas\&.bin\&.<i>\&.nregs" (\fBuint32_t\fR) r\-
.RS 4
Number of regions per page run\&.
.RE
.PP
"arenas\&.bin\&.<i>\&.run_size" (\fBsize_t\fR) r\-
.RS 4
Number of bytes per page run\&.
.RE
.PP
"arenas\&.nlruns" (\fBunsigned\fR) r\-
.RS 4
Total number of large size classes\&.
.RE
.PP
"arenas\&.lrun\&.<i>\&.size" (\fBsize_t\fR) r\-
.RS 4
Maximum size supported by this large size class\&.
.RE
.PP
"arenas\&.nhchunks" (\fBunsigned\fR) r\-
.RS 4
Total number of huge size classes\&.
.RE
.PP
"arenas\&.hchunk\&.<i>\&.size" (\fBsize_t\fR) r\-
.RS 4
Maximum size supported by this huge size class\&.
.RE
.PP
"arenas\&.extend" (\fBunsigned\fR) r\-
.RS 4
Extend the array of arenas by appending a new arena, and returning the new arena index\&.
.RE
.PP
"prof\&.thread_active_init" (\fBbool\fR) rw [\fB\-\-enable\-prof\fR]
.RS 4
Control the initial setting for
"thread\&.prof\&.active"
in newly created threads\&. See the
"opt\&.prof_thread_active_init"
option for additional information\&.
.RE
.PP
"prof\&.active" (\fBbool\fR) rw [\fB\-\-enable\-prof\fR]
.RS 4
Control whether sampling is currently active\&. See the
"opt\&.prof_active"
option for additional information, as well as the interrelated
"thread\&.prof\&.active"
mallctl\&.
.RE
.PP
"prof\&.dump" (\fBconst char *\fR) \-w [\fB\-\-enable\-prof\fR]
.RS 4
Dump a memory profile to the specified file, or if NULL is specified, to a file according to the pattern
<prefix>\&.<pid>\&.<seq>\&.m<mseq>\&.heap, where
<prefix>
is controlled by the
"opt\&.prof_prefix"
option\&.
.RE
.PP
"prof\&.gdump" (\fBbool\fR) rw [\fB\-\-enable\-prof\fR]
.RS 4
When enabled, trigger a memory profile dump every time the total virtual memory exceeds the previous maximum\&. Profiles are dumped to files named according to the pattern
<prefix>\&.<pid>\&.<seq>\&.u<useq>\&.heap, where
<prefix>
is controlled by the
"opt\&.prof_prefix"
option\&.
.RE
.PP
"prof\&.reset" (\fBsize_t\fR) \-w [\fB\-\-enable\-prof\fR]
.RS 4
Reset all memory profile statistics, and optionally update the sample rate (see
"opt\&.lg_prof_sample"
and
"prof\&.lg_sample")\&.
.RE
.PP
"prof\&.lg_sample" (\fBsize_t\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Get the current sample rate (see
"opt\&.lg_prof_sample")\&.
.RE
.PP
"prof\&.interval" (\fBuint64_t\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Average number of bytes allocated between inverval\-based profile dumps\&. See the
"opt\&.lg_prof_interval"
option for additional information\&.
.RE
.PP
"stats\&.cactive" (\fBsize_t *\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Pointer to a counter that contains an approximate count of the current number of bytes in active pages\&. The estimate may be high, but never low, because each arena rounds up when computing its contribution to the counter\&. Note that the
"epoch"
mallctl has no bearing on this counter\&. Furthermore, counter consistency is maintained via atomic operations, so it is necessary to use an atomic operation in order to guarantee a consistent read when dereferencing the pointer\&.
.RE
.PP
"stats\&.allocated" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Total number of bytes allocated by the application\&.
.RE
.PP
"stats\&.active" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Total number of bytes in active pages allocated by the application\&. This is a multiple of the page size, and greater than or equal to
"stats\&.allocated"\&. This does not include
"stats\&.arenas\&.<i>\&.pdirty", nor pages entirely devoted to allocator metadata\&.
.RE
.PP
"stats\&.metadata" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Total number of bytes dedicated to metadata, which comprise base allocations used for bootstrap\-sensitive internal allocator data structures, arena chunk headers (see
"stats\&.arenas\&.<i>\&.metadata\&.mapped"), and internal allocations (see
"stats\&.arenas\&.<i>\&.metadata\&.allocated")\&.
.RE
.PP
"stats\&.resident" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Maximum number of bytes in physically resident data pages mapped by the allocator, comprising all pages dedicated to allocator metadata, pages backing active allocations, and unused dirty pages\&. This is a maximum rather than precise because pages may not actually be physically resident if they correspond to demand\-zeroed virtual memory that has not yet been touched\&. This is a multiple of the page size, and is larger than
"stats\&.active"\&.
.RE
.PP
"stats\&.mapped" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Total number of bytes in active chunks mapped by the allocator\&. This is a multiple of the chunk size, and is larger than
"stats\&.active"\&. This does not include inactive chunks, even those that contain unused dirty pages, which means that there is no strict ordering between this and
"stats\&.resident"\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.dss" (\fBconst char *\fR) r\-
.RS 4
dss (\fBsbrk\fR(2)) allocation precedence as related to
\fBmmap\fR(2)
allocation\&. See
"opt\&.dss"
for details\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.lg_dirty_mult" (\fBssize_t\fR) r\-
.RS 4
Minimum ratio (log base 2) of active to dirty pages\&. See
"opt\&.lg_dirty_mult"
for details\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.nthreads" (\fBunsigned\fR) r\-
.RS 4
Number of threads currently assigned to arena\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.pactive" (\fBsize_t\fR) r\-
.RS 4
Number of pages in active runs\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.pdirty" (\fBsize_t\fR) r\-
.RS 4
Number of pages within unused runs that are potentially dirty, and for which
\fBmadvise\fR\fB\fI\&.\&.\&.\fR\fR\fB \fR\fB\fI\fBMADV_DONTNEED\fR\fR\fR
or similar has not been called\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.mapped" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Number of mapped bytes\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.metadata\&.mapped" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Number of mapped bytes in arena chunk headers, which track the states of the non\-metadata pages\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.metadata\&.allocated" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Number of bytes dedicated to internal allocations\&. Internal allocations differ from application\-originated allocations in that they are for internal use, and that they are omitted from heap profiles\&. This statistic is reported separately from
"stats\&.metadata"
and
"stats\&.arenas\&.<i>\&.metadata\&.mapped"
because it overlaps with e\&.g\&. the
"stats\&.allocated"
and
"stats\&.active"
statistics, whereas the other metadata statistics do not\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.npurge" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Number of dirty page purge sweeps performed\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.nmadvise" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Number of
\fBmadvise\fR\fB\fI\&.\&.\&.\fR\fR\fB \fR\fB\fI\fBMADV_DONTNEED\fR\fR\fR
or similar calls made to purge dirty pages\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.purged" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Number of pages purged\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.small\&.allocated" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Number of bytes currently allocated by small objects\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.small\&.nmalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of allocation requests served by small bins\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.small\&.ndalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of small objects returned to bins\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.small\&.nrequests" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of small allocation requests\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.large\&.allocated" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Number of bytes currently allocated by large objects\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.large\&.nmalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of large allocation requests served directly by the arena\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.large\&.ndalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of large deallocation requests served directly by the arena\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.large\&.nrequests" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of large allocation requests\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.huge\&.allocated" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Number of bytes currently allocated by huge objects\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.huge\&.nmalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of huge allocation requests served directly by the arena\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.huge\&.ndalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of huge deallocation requests served directly by the arena\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.huge\&.nrequests" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of huge allocation requests\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.bins\&.<j>\&.nmalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of allocations served by bin\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.bins\&.<j>\&.ndalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of allocations returned to bin\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.bins\&.<j>\&.nrequests" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of allocation requests\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.bins\&.<j>\&.curregs" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Current number of regions for this size class\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.bins\&.<j>\&.nfills" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR \fB\-\-enable\-tcache\fR]
.RS 4
Cumulative number of tcache fills\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.bins\&.<j>\&.nflushes" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR \fB\-\-enable\-tcache\fR]
.RS 4
Cumulative number of tcache flushes\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.bins\&.<j>\&.nruns" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of runs created\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.bins\&.<j>\&.nreruns" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of times the current run from which to allocate changed\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.bins\&.<j>\&.curruns" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Current number of runs\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.lruns\&.<j>\&.nmalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of allocation requests for this size class served directly by the arena\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.lruns\&.<j>\&.ndalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of deallocation requests for this size class served directly by the arena\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.lruns\&.<j>\&.nrequests" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of allocation requests for this size class\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.lruns\&.<j>\&.curruns" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Current number of runs for this size class\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.hchunks\&.<j>\&.nmalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of allocation requests for this size class served directly by the arena\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.hchunks\&.<j>\&.ndalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of deallocation requests for this size class served directly by the arena\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.hchunks\&.<j>\&.nrequests" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of allocation requests for this size class\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.hchunks\&.<j>\&.curhchunks" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Current number of huge allocations for this size class\&.
.RE
.SH "DEBUGGING MALLOC PROBLEMS"
.PP
When debugging, it is a good idea to configure/build jemalloc with the
\fB\-\-enable\-debug\fR
and
\fB\-\-enable\-fill\fR
options, and recompile the program with suitable options and symbols for debugger support\&. When so configured, jemalloc incorporates a wide variety of run\-time assertions that catch application errors such as double\-free, write\-after\-free, etc\&.
.PP
Programs often accidentally depend on \(lquninitialized\(rq memory actually being filled with zero bytes\&. Junk filling (see the
"opt\&.junk"
option) tends to expose such bugs in the form of obviously incorrect results and/or coredumps\&. Conversely, zero filling (see the
"opt\&.zero"
option) eliminates the symptoms of such bugs\&. Between these two options, it is usually possible to quickly detect, diagnose, and eliminate such bugs\&.
.PP
This implementation does not provide much detail about the problems it detects, because the performance impact for storing such information would be prohibitive\&. However, jemalloc does integrate with the most excellent
\m[blue]\fBValgrind\fR\m[]\&\s-2\u[2]\d\s+2
tool if the
\fB\-\-enable\-valgrind\fR
configuration option is enabled\&.
.SH "DIAGNOSTIC MESSAGES"
.PP
If any of the memory allocation/deallocation functions detect an error or warning condition, a message will be printed to file descriptor
\fBSTDERR_FILENO\fR\&. Errors will result in the process dumping core\&. If the
"opt\&.abort"
option is set, most warnings are treated as errors\&.
.PP
The
\fImalloc_message\fR
variable allows the programmer to override the function which emits the text strings forming the errors and warnings if for some reason the
\fBSTDERR_FILENO\fR
file descriptor is not suitable for this\&.
\fBmalloc_message\fR\fB\fR
takes the
\fIcbopaque\fR
pointer argument that is
\fBNULL\fR
unless overridden by the arguments in a call to
\fBmalloc_stats_print\fR\fB\fR, followed by a string pointer\&. Please note that doing anything which tries to allocate memory in this function is likely to result in a crash or deadlock\&.
.PP
All messages are prefixed by \(lq<jemalloc>:\(rq\&.
.SH "RETURN VALUES"
.SS "Standard API"
.PP
The
\fBmalloc\fR\fB\fR
and
\fBcalloc\fR\fB\fR
functions return a pointer to the allocated memory if successful; otherwise a
\fBNULL\fR
pointer is returned and
\fIerrno\fR
is set to
ENOMEM\&.
.PP
The
\fBposix_memalign\fR\fB\fR
function returns the value 0 if successful; otherwise it returns an error value\&. The
\fBposix_memalign\fR\fB\fR
function will fail if:
.PP
EINVAL
.RS 4
The
\fIalignment\fR
parameter is not a power of 2 at least as large as
sizeof(\fBvoid *\fR)\&.
.RE
.PP
ENOMEM
.RS 4
Memory allocation error\&.
.RE
.PP
The
\fBaligned_alloc\fR\fB\fR
function returns a pointer to the allocated memory if successful; otherwise a
\fBNULL\fR
pointer is returned and
\fIerrno\fR
is set\&. The
\fBaligned_alloc\fR\fB\fR
function will fail if:
.PP
EINVAL
.RS 4
The
\fIalignment\fR
parameter is not a power of 2\&.
.RE
.PP
ENOMEM
.RS 4
Memory allocation error\&.
.RE
.PP
The
\fBrealloc\fR\fB\fR
function returns a pointer, possibly identical to
\fIptr\fR, to the allocated memory if successful; otherwise a
\fBNULL\fR
pointer is returned, and
\fIerrno\fR
is set to
ENOMEM
if the error was the result of an allocation failure\&. The
\fBrealloc\fR\fB\fR
function always leaves the original buffer intact when an error occurs\&.
.PP
The
\fBfree\fR\fB\fR
function returns no value\&.
.SS "Non\-standard API"
.PP
The
\fBmallocx\fR\fB\fR
and
\fBrallocx\fR\fB\fR
functions return a pointer to the allocated memory if successful; otherwise a
\fBNULL\fR
pointer is returned to indicate insufficient contiguous memory was available to service the allocation request\&.
.PP
The
\fBxallocx\fR\fB\fR
function returns the real size of the resulting resized allocation pointed to by
\fIptr\fR, which is a value less than
\fIsize\fR
if the allocation could not be adequately grown in place\&.
.PP
The
\fBsallocx\fR\fB\fR
function returns the real size of the allocation pointed to by
\fIptr\fR\&.
.PP
The
\fBnallocx\fR\fB\fR
returns the real size that would result from a successful equivalent
\fBmallocx\fR\fB\fR
function call, or zero if insufficient memory is available to perform the size computation\&.
.PP
The
\fBmallctl\fR\fB\fR,
\fBmallctlnametomib\fR\fB\fR, and
\fBmallctlbymib\fR\fB\fR
functions return 0 on success; otherwise they return an error value\&. The functions will fail if:
.PP
EINVAL
.RS 4
\fInewp\fR
is not
\fBNULL\fR, and
\fInewlen\fR
is too large or too small\&. Alternatively,
\fI*oldlenp\fR
is too large or too small; in this case as much data as possible are read despite the error\&.
.RE
.PP
ENOENT
.RS 4
\fIname\fR
or
\fImib\fR
specifies an unknown/invalid value\&.
.RE
.PP
EPERM
.RS 4
Attempt to read or write void value, or attempt to write read\-only value\&.
.RE
.PP
EAGAIN
.RS 4
A memory allocation failure occurred\&.
.RE
.PP
EFAULT
.RS 4
An interface with side effects failed in some way not directly related to
\fBmallctl*\fR\fB\fR
read/write processing\&.
.RE
.PP
The
\fBmalloc_usable_size\fR\fB\fR
function returns the usable size of the allocation pointed to by
\fIptr\fR\&.
.SH "ENVIRONMENT"
.PP
The following environment variable affects the execution of the allocation functions:
.PP
\fBMALLOC_CONF\fR
.RS 4
If the environment variable
\fBMALLOC_CONF\fR
is set, the characters it contains will be interpreted as options\&.
.RE
.SH "EXAMPLES"
.PP
To dump core whenever a problem occurs:
.sp
.if n \{\
.RS 4
.\}
.nf
ln \-s \*(Aqabort:true\*(Aq /etc/malloc\&.conf
.fi
.if n \{\
.RE
.\}
.PP
To specify in the source a chunk size that is 16 MiB:
.sp
.if n \{\
.RS 4
.\}
.nf
malloc_conf = "lg_chunk:24";
.fi
.if n \{\
.RE
.\}
.SH "SEE ALSO"
.PP
\fBmadvise\fR(2),
\fBmmap\fR(2),
\fBsbrk\fR(2),
\fButrace\fR(2),
\fBalloca\fR(3),
\fBatexit\fR(3),
\fBgetpagesize\fR(3)
.SH "STANDARDS"
.PP
The
\fBmalloc\fR\fB\fR,
\fBcalloc\fR\fB\fR,
\fBrealloc\fR\fB\fR, and
\fBfree\fR\fB\fR
functions conform to ISO/IEC 9899:1990 (\(lqISO C90\(rq)\&.
.PP
The
\fBposix_memalign\fR\fB\fR
function conforms to IEEE Std 1003\&.1\-2001 (\(lqPOSIX\&.1\(rq)\&.
.SH "AUTHOR"
.PP
\fBJason Evans\fR
.RS 4
.RE
.SH "NOTES"
.IP " 1." 4
jemalloc website
.RS 4
\%http://www.canonware.com/jemalloc/
.RE
.IP " 2." 4
Valgrind
.RS 4
\%http://valgrind.org/
.RE
.IP " 3." 4
gperftools package
.RS 4
\%http://code.google.com/p/gperftools/
.RE
